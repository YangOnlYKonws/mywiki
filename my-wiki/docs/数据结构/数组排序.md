

## 单次遍历贪心

我认为这种其实也不属于贪心，只是因为都是找最佳，所以我写了贪心，又因为是无法回头的那种遍历形式，所以我叫它单次遍历，但是思路是差不多的。

思路：

1. 一次遍历
2. 数值替代
3. 大小比较

一次遍历就是顾名思义的遍历一次就够了，因为无法回头，数值替代，因为是贪心，肯定要数值替换的，如果当前值不满足题意，那就换数组中的下一值，大小比较指的是返回的最终值。

举两道例题：

1. 最大子数组和

   给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**子数组** 是数组中的一个连续部分。

   示例 1：

   输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
   输出：6
   解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
   示例 2：

   输入：nums = [1]
   输出：1
   示例 3：

   输入：nums = [5,4,-1,7,8]
   输出：23


   提示：

   1 <= nums.length <= 105
   -104 <= nums[i] <= 104

   分析：这个就是最典型的贪心，其实很多方法，有DP和贪心但是，最简洁的也最容易理解的还是单次遍历贪心

   代码：

   ```c
   int maxSubArray(int* nums, int numsSize){
       int i,max=nums[0],sum=0;
   
       for(i=0;i<numsSize;i++) //一次遍历
       {
           sum=sum+nums[i];	//数值替换
           if(sum<nums[i])
           {
               sum=nums[i];	//数值替换
           }
           if(max<=sum)		//大小比较
           {
               max=sum;
           }
       }
   
       return max;
   }
   ```

2. 买卖股票的最佳时机

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
示例 2：

输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。


提示：

1 <= prices.length <= 105
0 <= prices[i] <= 104

分析：不多说，找一个最小的，找一个最大的，要是能用人脑，数据小的话会很快，但是如果数据大就不行了，不过一次遍历他的时间，时间复杂度也不会很大，还是原来的思路一次遍历，数值替换，比较大小，一次遍历不说了，毕竟是个数值，为了不回头，数值替换就体现在，先找最小的，然后用当前的减最小的，得到的值替换最后输出值，这里连最后一步大小替换都覆盖了。

代码：

```C
int maxProfit(int* prices, int pricesSize){
    int i,numMin,max=0;
    numMin=prices[0];
    for(i=0;i<pricesSize;i++)
    {
        if(prices[i]<numMin)
        {
            numMin=prices[i];
        }

        if(prices[i]-numMin>max)
        {
            max=prices[i]-numMin;
        }
    }
    return max;
}
```

